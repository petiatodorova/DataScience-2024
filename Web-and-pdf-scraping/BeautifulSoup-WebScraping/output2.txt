Content from: https://www.crummy.com/software/BeautifulSoup/bs4/doc/

Beautiful Soupis a
Python library for pulling data out of HTML and XML files. It works
with your favorite parser to provide idiomatic ways of navigating,
searching, and modifying the parse tree. It commonly saves programmers
hours or days of work.
These instructions illustrate all major features of Beautiful Soup 4,
with examples. I show you what the library is good for, how it works,
how to use it, how to make it do what you want, and what to do when it
violates your expectations.
This document covers Beautiful Soup version 4.12.2. The examples in
this documentation were written for Python 3.8.
You might be looking for the documentation forBeautiful Soup 3.
If so, you should know that Beautiful Soup 3 is no longer being
developed and that all support for it was dropped on December
31, 2020. If you want to learn about the differences between Beautiful
Soup 3 and Beautiful Soup 4, seePorting code to BS4.
This documentation has been translated into other languages by
Beautiful Soup users:
这篇文档当然还有中文版.
このページは日本語で利用できます(外部リンク)
이 문서는 한국어 번역도 가능합니다.
Este documento também está disponível em Português do Brasil.
Este documento también está disponible en una traducción al español.
Эта документация доступна на русском языке.
If you have questions about Beautiful Soup, or run into problems,send mail to the discussion group. If
your problem involves parsing an HTML document, be sure to mentionwhat the diagnose() function saysabout
that document.
When reporting an error in this documentation, please mention which
translation you’re reading.
Here’s an HTML document I’ll be using as an example throughout this
document. It’s part of a story fromAlice in Wonderland:
Running the “three sisters” document through Beautiful Soup gives us aBeautifulSoupobject, which represents the document as a nested
data structure:
Here are some simple ways to navigate that data structure:
One common task is extracting all the URLs found within a page’s <a> tags:
Another common task is extracting all the text from a page:
Does this look like what you need? If so, read on.
If you’re using a recent version of Debian or Ubuntu Linux, you can
install Beautiful Soup with the system package manager:
$apt-getinstallpython3-bs4
Beautiful Soup 4 is published through PyPi, so if you can’t install it
with the system packager, you can install it witheasy_installorpip. The package name isbeautifulsoup4. Make sure you use the
right version ofpiporeasy_installfor your Python version
(these may be namedpip3andeasy_install3respectively).
$easy_installbeautifulsoup4
$pipinstallbeautifulsoup4
(TheBeautifulSouppackage isnotwhat you want. That’s
the previous major release,Beautiful Soup 3. Lots of software uses
BS3, so it’s still available, but if you’re writing new code you
should installbeautifulsoup4.)
If you don’t haveeasy_installorpipinstalled, you candownload the Beautiful Soup 4 source tarballand
install it withsetup.py.
$pythonsetup.pyinstall
If all else fails, the license for Beautiful Soup allows you to
package the entire library with your application. You can download the
tarball, copy itsbs4directory into your application’s codebase,
and use Beautiful Soup without installing it at all.
I use Python 3.10 to develop Beautiful Soup, but it should work with
other recent versions.
Beautiful Soup supports the HTML parser included in Python’s standard
library, but it also supports a number of third-party Python parsers.
One is thelxml parser. Depending on your setup,
you might install lxml with one of these commands:
$apt-getinstallpython-lxml
$easy_installlxml
$pipinstalllxml
Another alternative is the pure-Pythonhtml5lib parser, which parses HTML the way a
web browser does. Depending on your setup, you might install html5lib
with one of these commands:
$apt-getinstallpython3-html5lib
$pipinstallhtml5lib
This table summarizes the advantages and disadvantages of each parser library:
Parser
Typical usage
Advantages
Disadvantages
Python’s html.parser
BeautifulSoup(markup,"html.parser")
Batteries included
Decent speed
Not as fast as lxml,
less lenient than
html5lib.
lxml’s HTML parser
BeautifulSoup(markup,"lxml")
Very fast
External C dependency
lxml’s XML parser
BeautifulSoup(markup,"lxml-xml")BeautifulSoup(markup,"xml")
Very fast
The only currently supported
XML parser
External C dependency
html5lib
BeautifulSoup(markup,"html5lib")
Extremely lenient
Parses pages the same way a
web browser does
Creates valid HTML5
Very slow
External Python
dependency
If you can, I recommend you install and use lxml for speed.
Note that if a document is invalid, different parsers will generate
different Beautiful Soup trees for it. SeeDifferences
between parsersfor details.
To parse a document, pass it into theBeautifulSoupconstructor. You can pass in a string or an open filehandle:
First, the document is converted to Unicode, and HTML entities are
converted to Unicode characters:
Beautiful Soup then parses the document using the best available
parser. It will use an HTML parser unless you specifically tell it to
use an XML parser. (SeeParsing XML.)
Beautiful Soup transforms a complex HTML document into a complex tree
of Python objects. But you’ll only ever have to deal with about fourkindsof objects:Tag,NavigableString,BeautifulSoup,
andComment. These objects represent the HTMLelementsthat comprise the page.
ATagobject corresponds to an XML or HTML tag in the original document.
Tags have a lot of attributes and methods, and I’ll cover most of them
inNavigating the treeandSearching the tree. For now, the most
important methods of a tag are for accessing its name and attributes.
Every tag has a name:
If you change a tag’s name, the change will be reflected in any
markup generated by Beautiful Soup down the line:
An HTML or XML tag may have any number of attributes. The tag<bid="boldest">has an attribute “id” whose value is
“boldest”. You can access a tag’s attributes by treating the tag like
a dictionary:
You can access the dictionary of attributes directly as.attrs:
You can add, remove, and modify a tag’s attributes. Again, this is
done by treating the tag as a dictionary:
HTML 4 defines a few attributes that can have multiple values. HTML 5
removes a couple of them, but defines a few more. The most common
multi-valued attribute isclass(that is, a tag can have more than
one CSS class). Others includerel,rev,accept-charset,headers, andaccesskey. By default, Beautiful Soup stores the value(s)
of a multi-valued attribute as a list:
When you turn a tag back into a string, the values of any multi-valued
attributes are consolidated:
If an attributelookslike it has more than one value, but it’s not
a multi-valued attribute as defined by any version of the HTML
standard, Beautiful Soup stores it as a simple string:
You can force all attributes to be stored as strings by passingmulti_valued_attributes=Noneas a keyword argument into theBeautifulSoupconstructor:
You can useget_attribute_listto always return the value in a list
container, whether it’s a string or multi-valued attribute value:
If you parse a document as XML, there are no multi-valued attributes:
Again, you can configure this using themulti_valued_attributesargument:
You probably won’t need to do this, but if you do, use the defaults as
a guide. They implement the rules described in the HTML specification:
A tag can contain strings as pieces of text. Beautiful Soup
uses theNavigableStringclass to contain these pieces of text:
ANavigableStringis just like a Python Unicode string, except
that it also supports some of the features described inNavigating
the treeandSearching the tree. You can convert aNavigableStringto a Unicode string withstr:
You can’t edit a string in place, but you can replace one string with
another, usingreplace_with():
NavigableStringsupports most of the features described inNavigating the treeandSearching the tree, but not all of
them. In particular, since a string can’t contain anything (the way a
tag may contain a string or another tag), strings don’t support the.contentsor.stringattributes, or thefind()method.
If you want to use aNavigableStringoutside of Beautiful Soup,
you should callunicode()on it to turn it into a normal Python
Unicode string. If you don’t, your string will carry around a
reference to the entire Beautiful Soup parse tree, even when you’re
done using Beautiful Soup. This is a big waste of memory.
TheBeautifulSoupobject represents the parsed document as a
whole. For most purposes, you can treat it as aTagobject. This means it supports most of the methods described inNavigating the treeandSearching the tree.
You can also pass aBeautifulSoupobject into one of the methods
defined inModifying the tree, just as you would aTag. This
lets you do things like combine two parsed documents:
Since theBeautifulSoupobject doesn’t correspond to an actual
HTML or XML tag, it has no name and no attributes. But sometimes it’s
useful to reference its.name(such as when writing code that works
with bothTagandBeautifulSoupobjects),
so it’s been given the special.name“[document]”:
Tag,NavigableString, andBeautifulSoupcover almost everything you’ll see in an
HTML or XML file, but there are a few leftover bits. The main one
you’ll probably encounter is theComment.
TheCommentobject is just a special type ofNavigableString:
But when it appears as part of an HTML document, aCommentis
displayed with special formatting:
Beautiful Soup defines a fewNavigableStringsubclasses to
contain strings found inside specific HTML tags. This makes it easier
to pick out the main body of the page, by ignoring strings that
probably represent programming directives found within the
page.(These classes are new in Beautiful Soup 4.9.0, and the
html5lib parser doesn’t use them.)
ANavigableStringsubclass that represents embedded CSS
stylesheets; that is, any strings found inside a<style>tag
during document parsing.
ANavigableStringsubclass that represents embedded
Javascript; that is, any strings found inside a<script>tag
during document parsing.
ANavigableStringsubclass that represents embedded HTML
templates; that is, any strings found inside a<template>tag during
document parsing.
Beautiful Soup defines someNavigableStringclasses for
holding special types of strings that can be found in XML
documents. LikeComment, these classes are subclasses ofNavigableStringthat add something extra to the string on
output.
ANavigableStringsubclass representing thedeclarationat the beginning of
an XML document.
ANavigableStringsubclass representing thedocument type
declarationwhich may
be found near the beginning of an XML document.
ANavigableStringsubclass that represents aCData section.
ANavigableStringsubclass that represents the contents
of anXML processing instruction.
Here’s the “Three sisters” HTML document again:
I’ll use this as an example to show you how to move from one part of
a document to another.
Tags may contain strings and more tags. These elements are the tag’schildren. Beautiful Soup provides a lot of different attributes for
navigating and iterating over a tag’s children.
Note that Beautiful Soup strings don’t support any of these
attributes, because a string can’t have children.
The simplest way to navigate the parse tree is to find a tag by name. To
do this, you can use thefind()method:
For convenience, just saying the name of the tag you want is equivalent
tofind()(if no built-in attribute has that name). If you want the
<head> tag, just saysoup.head:
You can use this trick again and again to zoom in on a certain part
of the parse tree. This code gets the first <b> tag beneath the <body> tag:
find()(and its convenience equivalent) gives you only thefirsttag
by that name:
If you need to getallthe <a> tags, you can usefind_all():
For more complicated tasks, such as pattern-matching and filtering, you can
use the methods described inSearching the tree.
A tag’s children are available in a list called.contents:
TheBeautifulSoupobject itself has children. In this case, the
<html> tag is the child of theBeautifulSoupobject.:
A string does not have.contents, because it can’t contain
anything:
Instead of getting them as a list, you can iterate over a tag’s
children using the.childrengenerator:
If you want to modify a tag’s children, use the methods described inModifying the tree. Don’t modify the the.contentslist
directly: that can lead to problems that are subtle and difficult to
spot.
The.contentsand.childrenattributes consider only a tag’sdirectchildren. For instance, the <head> tag has a single direct
child–the <title> tag:
But the <title> tag itself has a child: the string “The Dormouse’s
story”. There’s a sense in which that string is also a child of the
<head> tag. The.descendantsattribute lets you iterate overallof a tag’s children, recursively: its direct children, the children of
its direct children, and so on:
The <head> tag has only one child, but it has two descendants: the
<title> tag and the <title> tag’s child. TheBeautifulSoupobject
only has one direct child (the <html> tag), but it has a whole lot of
descendants:
If a tag has only one child, and that child is aNavigableString,
the child is made available as.string:
If a tag’s only child is another tag, andthattag has a.string, then the parent tag is considered to have the same.stringas its child:
If a tag contains more than one thing, then it’s not clear what.stringshould refer to, so.stringis defined to beNone:
If there’s more than one thing inside a tag, you can still look at
just the strings. Use the.stringsgenerator to see all descendant
strings:
Newlines and spaces that separate tags are also strings. You can remove extra
whitespace by using the.stripped_stringsgenerator instead:
Here, strings consisting entirely of whitespace are ignored, and
whitespace at the beginning and end of strings is removed.
Continuing the “family tree” analogy, every tag and every string has aparent: the tag that contains it.
You can access an element’s parent with the.parentattribute. In
the example “three sisters” document, the <head> tag is the parent
of the <title> tag:
The title string itself has a parent: the <title> tag that contains
it:
The parent of a top-level tag like <html> is theBeautifulSoupobject
itself:
And the.parentof aBeautifulSoupobject is defined as None:
You can iterate over all of an element’s parents with.parents. This example uses.parentsto travel from an <a> tag
buried deep within the document, to the very top of the document:
Consider a simple document like this:
The <b> tag and the <c> tag are at the same level: they’re both direct
children of the same tag. We call themsiblings. When a document is
pretty-printed, siblings show up at the same indentation level. You
can also use this relationship in the code you write.
You can use.next_siblingand.previous_siblingto navigate
between page elements that are on the same level of the parse tree:
The <b> tag has a.next_sibling, but no.previous_sibling,
because there’s nothing before the <b> tagon the same level of the
tree. For the same reason, the <c> tag has a.previous_siblingbut no.next_sibling:
The strings “text1” and “text2” arenotsiblings, because they don’t
have the same parent:
In real documents, the.next_siblingor.previous_siblingof a
tag will usually be a string containing whitespace. Going back to the
“three sisters” document:
You might think that the.next_siblingof the first <a> tag would
be the second <a> tag. But actually, it’s a string: the comma and
newline that separate the first <a> tag from the second:
The second <a> tag is then the.next_siblingof the comma string:
You can iterate over a tag’s siblings with.next_siblingsor.previous_siblings:
(If the argument syntax to find tags by their attribute value is unfamiliar,
don’t worry; this is covered later inThe keyword arguments.)
Take a look at the beginning of the “three sisters” document:
An HTML parser takes this string of characters and turns it into a
series of events: “open an <html> tag”, “open a <head> tag”, “open a
<title> tag”, “add a string”, “close the <title> tag”, “open a <p>
tag”, and so on. The order in which the opening tags and strings are
encountered is calleddocument order. Beautiful Soup offers tools for
searching a document’s elements in document order.
The.next_elementattribute of a string or tag points to whatever
was parsed immediately after the opening of the current tag or after
the current string. It might be the same as.next_sibling, but it’s
usually drastically different.
Here’s the final <a> tag in the “three sisters” document. Its.next_siblingis a string: the conclusion of the sentence that was
interrupted by the start of the <a> tag:
But the.next_elementof that <a> tag, the thing that was parsed
immediately after the <a> tag, isnotthe rest of that sentence:
it’s the string “Tillie” inside it:
That’s because in the original markup, the word “Tillie” appeared
before that semicolon. The parser encountered an <a> tag, then the
word “Tillie”, then the closing </a> tag, then the semicolon and rest of
the sentence. The semicolon is on the same level as the <a> tag, but the
word “Tillie” was encountered first.
The.previous_elementattribute is the exact opposite of.next_element. It points to the opening tag or string that was
parsed immediately before this one:
You should get the idea by now. You can use these iterators to move
forward or backward in the document as it was parsed:
Beautiful Soup defines a lot of methods for searching the parse tree,
but they’re all very similar. I’m going to spend a lot of time explaining
the two most popular methods:find()andfind_all(). The other
methods take almost exactly the same arguments, so I’ll just cover
them briefly.
Once again, I’ll be using the “three sisters” document as an example:
By passing in a filter to a method likefind_all(), you can
zoom in on the parts of the document you’re interested in.
Before talking in detail aboutfind_all()and similar methods, I
want to show examples of different filters you can pass into these
methods. These filters show up again and again, throughout the
search API. You can use them to filter based on a tag’s name,
on its attributes, on the text of a string, or on some combination of
these.
The simplest filter is a string. Pass a string to a search method and
Beautiful Soup will perform a tag-name match against that exact string.
This code finds all the <b> tags in the document:
If you pass in a byte string, Beautiful Soup will assume the string is
encoded as UTF-8. You can avoid this by passing in a Unicode string instead.
If you pass in a regular expression object, Beautiful Soup will filter
against that regular expression using itssearch()method. This code
finds all the tags whose names start with the letter “b”; in this
case, the <body> tag and the <b> tag:
This code finds all the tags whose names contain the letter ‘t’:
The valueTruematches every tag it can. This code findsallthe tags in the document, but none of the text strings:
If none of the other matches work for you, define a function that
takes an element as its only argument. The function should returnTrueif the argument matches, andFalseotherwise.
Here’s a function that returnsTrueif a tag defines the “class”
attribute but doesn’t define the “id” attribute:
Pass this function intofind_all()and you’ll pick up all the <p>
tags:
This function picks up only the <p> tags. It doesn’t pick up the <a>
tags, because those tags define both “class” and “id”. It doesn’t pick
up tags like <html> and <title>, because those tags don’t define
“class”.
The function can be as complicated as you need it to be. Here’s a
function that returnsTrueif a tag is surrounded by string
objects:
If you pass in a list, Beautiful Soup will look for a match againstanystring, regular expression, or function in that list. This
code finds all the <a> tagsandall the <b> tags:
Now we’re ready to look at the search methods in detail.
Method signature: find_all(name,attrs,recursive,string,limit,**kwargs)
Thefind_all()method looks through a tag’s descendants and
retrievesalldescendants that match your filters. I gave several
examples inKinds of filters, but here are a few more:
Some of these should look familiar, but others are new. What does it
mean to pass in a value forstring, orid? Why doesfind_all("p","title")find a <p> tag with the CSS class “title”?
Let’s look at the arguments tofind_all().
Pass in a value fornameand you’ll tell Beautiful Soup to only
consider tags with certain names. Text strings will be ignored, as
will tags whose names that don’t match.
This is the simplest usage:
Recall fromKinds of filtersthat the value tonamecan bea
string,a regular expression,a list,a function, orthe value
True.
Any keyword argument that’s not recognized will be turned into a filter
that matches tags by their attributes.
If you pass in a value for an argument calledid, Beautiful Soup will
filter against each tag’s ‘id’ attribute value:
Just as with tags, you can filter an attribute based ona string,a regular expression,a list,a function, orthe value True.
If you pass in a regular expression object forhref, Beautiful Soup will
pattern-match against each tag’s ‘href’ attribute value:
The valueTruematches every tag that defines the attribute. This code
findsalltags with anidattribute:
soup.find_all(id=True)
# [<a class=”sister” href=”http://example.com/elsie” id=”link1”>Elsie</a>,
#  <a class=”sister” href=”http://example.com/lacie” id=”link2”>Lacie</a>,
#  <a class=”sister” href=”http://example.com/tillie” id=”link3”>Tillie</a>]
For more complex matches, you can define a function that takes an attribute
value as its only argument. The function should returnTrueif the value
matches, andFalseotherwise.
Here’s a function that finds allatags whosehrefattributedoes notmatch a regular expression:
If you pass in a list for an argument, Beautiful Soup will look for an
attribute-value match againstanystring, regular expression, or function in
that list. This code finds the first and last link:
soup.find_all(id=[“link1”, re.compile(“3$”)])
# [<a class=”sister” href=”http://example.com/elsie” id=”link1”>Elsie</a>,
#  <a class=”sister” href=”http://example.com/tillie” id=”link3”>Tillie</a>]
You can filter against multiple attributes at once by passing multiple
keyword arguments:
Some attributes, like the data-* attributes in HTML 5, have names that
can’t be used as the names of keyword arguments:
You can use these attributes in searches by putting them into a
dictionary and passing the dictionary intofind_all()as theattrsargument:
Similarly, you can’t use a keyword argument to search for HTML’s ‘name’ attribute,
because Beautiful Soup uses thenameargument to contain the name
of the tag itself. Instead, you can give a value to ‘name’ in theattrsargument:
It’s very useful to search for a tag that has a certain CSS class, but
the name of the CSS attribute, “class”, is a reserved word in
Python. Usingclassas a keyword argument will give you a syntax
error. As of Beautiful Soup 4.1.2, you can search by CSS class using
the keyword argumentclass_:
As with any keyword argument, you can passclass_a string, a regular
expression, a function, orTrue:
Rememberthat a single tag can have multiple
values for its “class” attribute. When you search for a tag that
matches a certain CSS class, you’re matching againstanyof its CSS
classes:
You can also search for the exact string value of theclassattribute:
But searching for variants of the string value won’t work:
In older versions of Beautiful Soup, which don’t have theclass_shortcut, you can use theattrsargument trick mentioned above.
Create a dictionary whose value for “class” is the string (or regular
expression, or whatever) you want to search for:
To search for tags that match two or more CSS classes at once, use theselect()CSS selector methoddescribed here:
With thestringargument, you can search for strings instead of tags. As
withnameand attribute keyword arguments, you can pass ina string,a
regular expression,a function,a list, orthe value True.
Here are some examples:
If you use thestringargument in a tag search, Beautiful Soup will find
all tags whose.stringmatches your value forstring. This code finds
the <a> tags whose.stringis “Elsie”:
Thestringargument is new in Beautiful Soup 4.4.0. In earlier
versions it was calledtext:
find_all()returns all the tags and strings that match your
filters. This can take a while if the document is large. If you don’t
needallthe results, you can pass in a number forlimit. This
works just like the LIMIT keyword in SQL. It tells Beautiful Soup to
stop gathering results after it’s found a certain number.
There are three links in the “three sisters” document, but this code
only finds the first two:
By default,mytag.find_all()will examine all the descendants ofmytag:
its children, its children’s children, and so on. To consider only direct
children, you can pass inrecursive=False. See the difference here:
Here’s that part of the document:
The <title> tag is beneath the <html> tag, but it’s notdirectlybeneath the <html> tag: the <head> tag is in the way. Beautiful Soup
finds the <title> tag when it’s allowed to look at all descendants of
the <html> tag, but whenrecursive=Falserestricts it to the
<html> tag’s immediate children, it finds nothing.
Beautiful Soup offers a lot of tree-searching methods (covered below),
and they mostly take the same arguments asfind_all():name,attrs,string,limit, and attribute keyword arguments. But therecursiveargument is specific to thefind_all()andfind()methods.
Passingrecursive=Falseinto a method likefind_parents()wouldn’t be
very useful.
For convenience, calling aBeautifulSoupobject orTagobject as a function is equivalent to callingfind_all()(if no built-in method has the name of the tag you’re
looking for). These two lines of code are equivalent:
These two lines are also equivalent:
Method signature: find(name,attrs,recursive,string,**kwargs)
Thefind_all()method scans the entire document looking for
results, but sometimes you only want to find one result. If you know a
document has only one <body> tag, it’s a waste of time to scan the
entire document looking for more. Rather than passing inlimit=1every time you callfind_all, you can use thefind()method. These two lines of code arenearlyequivalent:
The only difference is thatfind_all()returns a list containing
the single result, andfind()just returns the result.
Iffind_all()can’t find anything, it returns an empty list. Iffind()can’t find anything, it returnsNone:
Remember thesoup.head.titletrick fromNavigating using tag
names? That trick works by repeatedly callingfind():
Method signature: find_parents(name,attrs,string,limit,**kwargs)
Method signature: find_parent(name,attrs,string,**kwargs)
I spent a lot of time above coveringfind_all()andfind(). The Beautiful Soup API defines ten other methods for
searching the tree, but don’t be afraid. Five of these methods are
basically the same asfind_all(), and the other five are basically
the same asfind(). The only differences are in how they move from
one part of the tree to another.
First let’s considerfind_parents()andfind_parent(). Remember thatfind_all()andfind()work
their way down the tree, looking at tag’s descendants. These methods
do the opposite: they work their wayupthe tree, looking at a tag’s
(or a string’s) parents. Let’s try them out, starting from a string
buried deep in the “three daughters” document:
One of the three <a> tags is the direct parent of the string in
question, so our search finds it. One of the three <p> tags is an
indirect parent (ancestor) of the string, and our search finds that as
well. There’s a <p> tag with the CSS class “title”somewherein the
document, but it’s not one of this string’s parents, so we can’t find
it withfind_parents().
You may have noticed a similarity betweenfind_parent()andfind_parents(), and the.parentand.parentsattributes
mentioned earlier. These search methods actually use the.parentsattribute to iterate through all parents (unfiltered), checking each one
against the provided filter to see if it matches.
Method signature: find_next_siblings(name,attrs,string,limit,**kwargs)
Method signature: find_next_sibling(name,attrs,string,**kwargs)
These methods use.next_siblingsto
iterate over the rest of an element’s siblings in the tree. Thefind_next_siblings()method returns all the siblings that match,
andfind_next_sibling()returns only the first one:
Method signature: find_previous_siblings(name,attrs,string,limit,**kwargs)
Method signature: find_previous_sibling(name,attrs,string,**kwargs)
These methods use.previous_siblingsto iterate over an element’s
siblings that precede it in the tree. Thefind_previous_siblings()method returns all the siblings that match, andfind_previous_sibling()returns only the first one:
Method signature: find_all_next(name,attrs,string,limit,**kwargs)
Method signature: find_next(name,attrs,string,**kwargs)
These methods use.next_elementsto
iterate over whatever tags and strings that come after it in the
document. Thefind_all_next()method returns all matches, andfind_next()returns only the first match:
In the first example, the string “Elsie” showed up, even though it was
contained within the <a> tag we started from. In the second example,
the last <p> tag in the document showed up, even though it’s not in
the same part of the tree as the <a> tag we started from. For these
methods, all that matters is that an element matches the filter and
it shows up later in the document indocument order.
Method signature: find_all_previous(name,attrs,string,limit,**kwargs)
Method signature: find_previous(name,attrs,string,**kwargs)
These methods use.previous_elementsto
iterate over the tags and strings that came before it in the
document. Thefind_all_previous()method returns all matches, andfind_previous()only returns the first match:
The call tofind_all_previous("p")found the first paragraph in
the document (the one with class=”title”), but it also finds the
second paragraph, the <p> tag that contains the <a> tag we started
with. This shouldn’t be too surprising: we’re looking at all the tags
that show up earlier in the document indocument orderthan the one we started with. A
<p> tag that contains an <a> tag must have shown up before the <a>
tag it contains.
BeautifulSoupandTagobjects support CSS selectors through
their.cssproperty. The actual selector implementation is handled
by theSoup Sievepackage, available on PyPI assoupsieve. If you installed
Beautiful Soup throughpip, Soup Sieve was installed at the same
time, so you don’t have to do anything extra.
The Soup Sieve documentation listsall the currently supported CSS
selectors, but
here are some of the basics. You can find tags by name:
Find tags by ID:
Find tags contained anywhere within other tags:
Find tagsdirectlywithin other tags:
Find all matching next siblings of tags:
Find the next sibling tag (but only if it matches):
Find tags by CSS class:
Find tags that match any selector from a list of selectors:
Test for the existence of an attribute:
Find tags by attribute value:
There’s also a method calledselect_one(), which finds only the
first tag that matches a selector:
As a convenience, you can callselect()andselect_one()can
directly on theBeautifulSouporTagobject, omitting the.cssproperty:
CSS selector support is a convenience for people who already know the
CSS selector syntax. You can do all of this with the Beautiful Soup
API. If CSS selectors are all you need, you should skip Beautiful Soup
altogether and parse the document withlxml: it’s a lot
faster. But Soup Sieve lets youcombineCSS selectors with the
Beautiful Soup API.
Soup Sieve offers a substantial API beyond theselect()andselect_one()methods, and you can access most of that API through
the.cssattribute ofTagorBeautifulSoup. What follows
is just a list of the supported methods; seethe Soup Sieve
documentationfor full
documentation.
Theiselect()method works the same asselect(), but it
returns a generator instead of a list:
Theclosest()method returns the nearest parent of a givenTagthat matches a CSS selector, similar to Beautiful Soup’sfind_parent()method:
Thematch()method returns a Boolean depending on whether or not a
specificTagmatches a selector:
Thefilter()method returns the subset of a tag’s direct children
that match a selector:
Theescape()method escapes CSS identifiers that would otherwise
be invalid:
If you’ve parsed XML that defines namespaces, you can use them in CSS
selectors.:
Beautiful Soup tries to use namespace prefixes that make sense based
on what it saw while parsing the document, but you can always provide
your own dictionary of abbreviations:
The.cssproperty was added in Beautiful Soup 4.12.0. Prior to this,
only the.select()and.select_one()convenience methods were
supported.
The Soup Sieve integration was added in Beautiful Soup 4.7.0. Earlier
versions had the.select()method, but only the most commonly-used
CSS selectors were supported.
Beautiful Soup’s main strength is in searching the parse tree, but you
can also modify the tree and write your changes as a new HTML or XML
document.
I covered this earlier, inTag.attrs, but it bears repeating. You
can rename a tag, change the values of its attributes, add new
attributes, and delete attributes:
If you set a tag’s.stringattribute to a new string, the tag’s contents are
replaced with that string:
Be careful: if the tag contained other tags, they and all their
contents will be destroyed.
You can add to a tag’s contents withTag.append(). It works just
like calling.append()on a Python list:
Starting in Beautiful Soup 4.7.0,Tagalso supports a method
called.extend(), which adds every element of a list to aTag,
in order:
If you need to add a string to a document, no problem–you can pass a
Python string in toappend(), or you can call theNavigableStringconstructor:
If you want to create a comment or some other subclass ofNavigableString, just call the constructor:
(This is a new feature in Beautiful Soup 4.4.0.)
What if you need to create a whole new tag? The best solution is to
call the factory methodBeautifulSoup.new_tag():
Only the first argument, the tag name, is required.
Tag.insert()is just likeTag.append(), except the new element
doesn’t necessarily go at the end of its parent’s.contents. It’ll be inserted at whatever numeric position you
say. It works just like.insert()on a Python list:
Theinsert_before()method inserts tags or strings immediately
before something else in the parse tree:
Theinsert_after()method inserts tags or strings immediately
following something else in the parse tree:
Tag.clear()removes the contents of a tag:
PageElement.extract()removes a tag or string from the tree. It
returns the tag or string that was extracted:
At this point you effectively have two parse trees: one rooted at theBeautifulSoupobject you used to parse the document, and one rooted
at the tag that was extracted. You can go on to callextract()on
a child of the element you extracted:
Tag.decompose()removes a tag from the tree, thencompletely
destroys it and its contents:
The behavior of a decomposedTagorNavigableStringis not
defined and you should not use it for anything. If you’re not sure
whether something has been decomposed, you can check its.decomposedproperty(new in Beautiful Soup 4.9.0):
PageElement.replace_with()extracts a tag or string from the tree,
then replaces it with one or more tags or strings of your choice:
replace_with()returns the tag or string that got replaced, so
that you can examine it or add it back to another part of the tree.
The ability to pass multiple arguments into replace_with() is new
in Beautiful Soup 4.10.0.
PageElement.wrap()wraps an element in theTagobject you specify. It
returns the new wrapper:
This method is new in Beautiful Soup 4.0.5.
Tag.unwrap()is the opposite ofwrap(). It replaces a tag with
whatever’s inside that tag. It’s good for stripping out markup:
Likereplace_with(),unwrap()returns the tag
that was replaced.
After calling a bunch of methods that modify the parse tree, you may end up
with two or moreNavigableStringobjects next to each other.
Beautiful Soup doesn’t have any problems with this, but since it can’t happen
in a freshly parsed document, you might not expect behavior like the
following:
You can callTag.smooth()to clean up the parse tree by consolidating adjacent strings:
This method is new in Beautiful Soup 4.8.0.
Theprettify()method will turn a Beautiful Soup parse tree into a
nicely formatted Unicode string, with a separate line for each
tag and each string:
You can callprettify()on the top-levelBeautifulSoupobject,
or on any of itsTagobjects:
Since it adds whitespace (in the form of newlines),prettify()changes the meaning of an HTML document and should not be used to
reformat one. The goal ofprettify()is to help you visually
understand the structure of the documents you work with.
If you just want a string, with no fancy formatting, you can callstr()on aBeautifulSoupobject, or on aTagwithin it:
Thestr()function returns a string encoded in UTF-8. SeeEncodingsfor other options.
You can also callencode()to get a bytestring, anddecode()to get Unicode.
If you give Beautiful Soup a document that contains HTML entities like
“&lquot;”, they’ll be converted to Unicode characters:
If you then convert the document to a bytestring, the Unicode characters
will be encoded as UTF-8. You won’t get the HTML entities back:
By default, the only characters that are escaped upon output are bare
ampersands and angle brackets. These get turned into “&amp;”, “&lt;”,
and “&gt;”, so that Beautiful Soup doesn’t inadvertently generate
invalid HTML or XML:
You can change this behavior by providing a value for theformatterargument toprettify(),encode(), ordecode(). Beautiful Soup recognizes five possible values forformatter.
The default isformatter="minimal". Strings will only be processed
enough to ensure that Beautiful Soup generates valid HTML/XML:
If you pass informatter="html", Beautiful Soup will convert
Unicode characters to HTML entities whenever possible:
If you pass informatter="html5", it’s similar toformatter="html", but Beautiful Soup will
omit the closing slash in HTML void tags like “br”:
In addition, any attributes whose values are the empty string
will become HTML-style Boolean attributes:
(This behavior is new as of Beautiful Soup 4.10.0.)
If you pass informatter=None, Beautiful Soup will not modify
strings at all on output. This is the fastest option, but it may lead
to Beautiful Soup generating invalid HTML/XML, as in these examples:
If you need more sophisticated control over your output, you can
instantiate one of Beautiful Soup’s formatter classes and pass that
object in asformatter.
Used to customize the formatting rules for HTML documents.
Here’s a formatter that converts strings to uppercase, whether they
occur in a string object or an attribute value:
Here’s a formatter that increases the indentation width when pretty-printing:
Used to customize the formatting rules for XML documents.
SubclassingHTMLFormatterorXMLFormatterwill
give you even more control over the output. For example, Beautiful
Soup sorts the attributes in every tag by default:
To turn this off, you can subclass theFormatter.attributes()method, which controls which attributes are output and in what
order. This implementation also filters out the attribute called “m”
whenever it appears:
One last caveat: if you create aCDataobject, the text inside
that object is always presentedexactly as it appears, with no
formatting. Beautiful Soup will call your entity substitution
function, just in case you’ve written a custom function that counts
all the strings in the document or something, but it will ignore the
return value:
If you only want the human-readable text inside a document or tag, you can use theget_text()method. It returns all the text in a document or
beneath a tag, as a single Unicode string:
You can specify a string to be used to join the bits of text
together:
You can tell Beautiful Soup to strip whitespace from the beginning and
end of each bit of text:
But at that point you might want to use the.stripped_stringsgenerator instead, and process the text yourself:
As of Beautiful Soup version 4.9.0, when lxml or html.parser are in
use, the contents of <script>, <style>, and <template>
tags are generally not considered to be ‘text’, since those tags are not part of
the human-visible content of the page.
As of Beautiful Soup version 4.10.0, you can call get_text(),
.strings, or .stripped_strings on a NavigableString object. It will
either return the object itself, or nothing, so the only reason to do
this is when you’re iterating over a mixed list.
If you just need to parse some HTML, you can dump the markup into theBeautifulSoupconstructor, and it’ll probably be fine. Beautiful
Soup will pick a parser for you and parse the data. But there are a
few additional arguments you can pass in to the constructor to change
which parser is used.
The first argument to theBeautifulSoupconstructor is a string or
an open filehandle—the source of the markup you want parsed. The second
argument ishowyou’d like the markup parsed.
If you don’t specify anything, you’ll get the best HTML parser that’s
installed. Beautiful Soup ranks lxml’s parser as being the best, then
html5lib’s, then Python’s built-in parser. You can override this by
specifying one of the following:
What type of markup you want to parse. Currently supported values are
“html”, “xml”, and “html5”.
The name of the parser library you want to use. Currently supported
options are “lxml”, “html5lib”, and “html.parser” (Python’s
built-in HTML parser).
The sectionInstalling a parsercontrasts the supported parsers.
If you don’t have an appropriate parser installed, Beautiful Soup will
ignore your request and pick a different parser. Right now, the only
supported XML parser is lxml. If you don’t have lxml installed, asking
for an XML parser won’t give you one, and asking for “lxml” won’t work
either.
Beautiful Soup presents the same interface to a number of different
parsers, but each parser is different. Different parsers will create
different parse trees from the same document. The biggest differences
are between the HTML parsers and the XML parsers. Here’s a short
document, parsed as HTML using the parser that comes with Python:
Since a standalone <b/> tag is not valid HTML, html.parser turns it into
a <b></b> tag pair.
Here’s the same document parsed as XML (running this requires that you
have lxml installed). Note that the standalone <b/> tag is left alone, and
that the document is given an XML declaration instead of being put
into an <html> tag.:
There are also differences between HTML parsers. If you give Beautiful
Soup a perfectly-formed HTML document, these differences won’t
matter. One parser will be faster than another, but they’ll all give
you a data structure that looks exactly like the original HTML
document.
But if the document is not perfectly-formed, different parsers will
give different results. Here’s a short, invalid document parsed using
lxml’s HTML parser. Note that the <a> tag gets wrapped in <body> and
<html> tags, and the dangling </p> tag is simply ignored:
Here’s the same document parsed using html5lib:
Instead of ignoring the dangling </p> tag, html5lib pairs it with an
opening <p> tag. html5lib also adds an empty <head> tag; lxml didn’t
bother.
Here’s the same document parsed with Python’s built-in HTML
parser:
Like lxml, this parser ignores the closing </p> tag. Unlike
html5lib or lxml, this parser makes no attempt to create a
well-formed HTML document by adding <html> or <body> tags.
Since the document “<a></p>” is invalid, none of these techniques is
the ‘correct’ way to handle it. The html5lib parser uses techniques
that are part of the HTML5 standard, so it has the best claim on being
the ‘correct’ way, but all three techniques are legitimate.
Differences between parsers can affect your script. If you’re planning
on distributing your script to other people, or running it on multiple
machines, you should specify a parser in theBeautifulSoupconstructor. That will reduce the chances that your users parse a
document differently from the way you parse it.
Any HTML or XML document is written in a specific encoding like ASCII
or UTF-8. But when you load that document into Beautiful Soup, you’ll
discover it’s been converted to Unicode:
It’s not magic. (That sure would be nice.) Beautiful Soup uses a
sub-library calledUnicode, Dammitto detect a document’s encoding
and convert it to Unicode. The autodetected encoding is available as
the.original_encodingattribute of theBeautifulSoupobject:
Unicode, Dammit guesses correctly most of the time, but sometimes it
makes mistakes. Sometimes it guesses correctly, but only after a
byte-by-byte search of the document that takes a very long time. If
you happen to know a document’s encoding ahead of time, you can avoid
mistakes and delays by passing it to theBeautifulSoupconstructor
asfrom_encoding.
Here’s a document written in ISO-8859-8. The document is so short that
Unicode, Dammit can’t get a lock on it, and misidentifies it as
ISO-8859-7:
We can fix this by passing in the correctfrom_encoding:
If you don’t know what the correct encoding is, but you know that
Unicode, Dammit is guessing wrong, you can pass the wrong guesses in
asexclude_encodings:
Windows-1255 isn’t 100% correct, but that encoding is a compatible
superset of ISO-8859-8, so it’s close enough. (exclude_encodingsis a new feature in Beautiful Soup 4.4.0.)
In rare cases (usually when a UTF-8 document contains text written in
a completely different encoding), the only way to get Unicode may be
to replace some characters with the special Unicode character
“REPLACEMENT CHARACTER” (U+FFFD, �). If Unicode, Dammit needs to do
this, it will set the.contains_replacement_charactersattribute
toTrueon theUnicodeDammitorBeautifulSoupobject. This
lets you know that the Unicode representation is not an exact
representation of the original–some data was lost. If a document
contains �, but.contains_replacement_charactersisFalse,
you’ll know that the � was there originally (as it is in this
paragraph) and doesn’t stand in for missing data.
When you write out an output document from Beautiful Soup, you get a UTF-8
document, even if the input document wasn’t in UTF-8 to begin with. Here’s a
document written in the Latin-1 encoding:
Note that the <meta> tag has been rewritten to reflect the fact that
the document is now in UTF-8.
If you don’t want UTF-8, you can pass an encoding intoprettify():
You can also call encode() on theBeautifulSoupobject, or any
element in the soup, just as if it were a Python string:
Any characters that can’t be represented in your chosen encoding will
be converted into numeric XML entity references. Here’s a document
that includes the Unicode character SNOWMAN:
The SNOWMAN character can be part of a UTF-8 document (it looks like
☃), but there’s no representation for that character in ISO-Latin-1 or
ASCII, so it’s converted into “&#9731” for those encodings:
You can use Unicode, Dammit without using Beautiful Soup. It’s useful
whenever you have data in an unknown encoding and you just want it to
become Unicode:
Unicode, Dammit’s guesses will get a lot more accurate if you install
one of these Python libraries:charset-normalizer,chardet, orcchardet. The more data you give Unicode, Dammit, the more
accurately it will guess. If you have your own suspicions as to what
the encoding might be, you can pass them in as a list:
Unicode, Dammit has two special features that Beautiful Soup doesn’t
use.
You can use Unicode, Dammit to convert Microsoft smart quotes to HTML or XML
entities:
You can also convert Microsoft smart quotes to ASCII quotes:
Hopefully you’ll find this feature useful, but Beautiful Soup doesn’t
use it. Beautiful Soup prefers the default behavior, which is to
convert Microsoft smart quotes to Unicode characters along with
everything else:
Sometimes a document is mostly in UTF-8, but contains Windows-1252
characters such as (again) Microsoft smart quotes. This can happen
when a website includes data from multiple sources. You can useUnicodeDammit.detwingle()to turn such a document into pure
UTF-8. Here’s a simple example:
This document is a mess. The snowmen are in UTF-8 and the quotes are
in Windows-1252. You can display the snowmen or the quotes, but not
both:
Decoding the document as UTF-8 raises aUnicodeDecodeError, and
decoding it as Windows-1252 gives you gibberish. Fortunately,UnicodeDammit.detwingle()will convert the string to pure UTF-8,
allowing you to decode it to Unicode and display the snowmen and quote
marks simultaneously:
UnicodeDammit.detwingle()only knows how to handle Windows-1252
embedded in UTF-8 (or vice versa, I suppose), but this is the most
common case.
Note that you must know to callUnicodeDammit.detwingle()on your
data before passing it intoBeautifulSoupor theUnicodeDammitconstructor. Beautiful Soup assumes that a document has a single
encoding, whatever it might be. If you pass it a document that
contains both UTF-8 and Windows-1252, it’s likely to think the whole
document is Windows-1252, and the document will come out looking likeâ˜ƒâ˜ƒâ˜ƒ“Ilikesnowmen!”.
UnicodeDammit.detwingle()is new in Beautiful Soup 4.1.0.
Thehtml.parserandhtml5libparsers can keep track of where in
the original document eachTagwas found. You can access this
information asTag.sourceline(line number) andTag.sourcepos(position of the start tag within a line):
Note that the two parsers mean slightly different things bysourcelineandsourcepos. For html.parser, these numbers
represent the position of the initial less-than sign. For html5lib,
these numbers represent the position of the final greater-than sign:
You can shut off this feature by passingstore_line_numbers=Falseinto theBeautifulSoupconstructor:
This feature is new in 4.8.1, and the parsers based on lxml don’t
support it.
Beautiful Soup says that twoNavigableStringorTagobjects
are equal when they represent the same HTML or XML markup, even if their
attributes are in a different order or they live in different parts of the
object tree. In this example, the two <b> tags are treated as equal, because
they both look like “<b>pizza</b>”:
If you want to see whether two variables refer to exactly the same
object, useis:
You can usecopy.copy()to create a copy of anyTagorNavigableString:
The copy is considered equal to the original, since it represents the
same markup as the original, but it’s not the same object:
The only real difference is that the copy is completely detached from
the original Beautiful Soup object tree, just as ifextract()had
been called on it:
This is because two differentTagobjects can’t occupy the same
space at the same time.
Beautiful Soup offers a number of ways to customize how the parser
treats incoming HTML and XML. This section covers the most commonly
used customization techniques.
Let’s say you want to use Beautiful Soup to look at a document’s <a>
tags. It’s a waste of time and memory to parse the entire document and
then go over it again looking for <a> tags. It would be much faster to
ignore everything that wasn’t an <a> tag in the first place. TheSoupStrainerclass allows you to choose which parts of an incoming
document are parsed. You just create aSoupStrainerand pass it in
to theBeautifulSoupconstructor as theparse_onlyargument.
(Note thatthis feature won’t work if you’re using the html5lib parser.
If you use html5lib, the whole document will be parsed, no
matter what. This is because html5lib constantly rearranges the parse
tree as it works, and if some part of the document didn’t actually
make it into the parse tree, it’ll crash. To avoid confusion, in the
examples below I’ll be forcing Beautiful Soup to use Python’s
built-in parser.)
TheSoupStrainerclass takes the same arguments as a typical
method fromSearching the tree:name,attrs,string, and**kwargs. Here are
threeSoupStrainerobjects:
I’m going to bring back the “three sisters” document one more time,
and we’ll see what the document looks like when it’s parsed with these
threeSoupStrainerobjects:
TheSoupStrainerbehavior is as follows:
When a tag matches, it is kept (including all its contents, whether they also
match or not).
When a tag does not match, the tag itself is not kept, but parsing continues
into its contents to look for other tags that do match.
You can also pass aSoupStrainerinto any of the methods covered
inSearching the tree. This probably isn’t terribly useful, but I
thought I’d mention it:
In an HTML document, an attribute likeclassis given a list of
values, and an attribute likeidis given a single value, because
the HTML specification treats those attributes differently:
You can turn this off by passing inmulti_valued_attributes=None. Than all attributes will be given a
single value:
You can customize this behavior quite a bit by passing in a
dictionary formulti_valued_attributes. If you need this, look atHTMLTreeBuilder.DEFAULT_CDATA_LIST_ATTRIBUTESto see the
configuration Beautiful Soup uses by default, which is based on the
HTML specification.
(This is a new feature in Beautiful Soup 4.8.0.)
When using thehtml.parserparser, you can use theon_duplicate_attributeconstructor argument to customize what
Beautiful Soup does when it encounters a tag that defines the same
attribute more than once:
The default behavior is to use the last value found for the tag:
Withon_duplicate_attribute='ignore'you can tell Beautiful Soup
to use thefirstvalue found and ignore the rest:
(lxml and html5lib always do it this way; their behavior can’t be
configured from within Beautiful Soup.)
If you need more control, you can pass in a function that’s called on each
duplicate value:
(This is a new feature in Beautiful Soup 4.9.1.)
When a parser tells Beautiful Soup about a tag or a string, Beautiful
Soup will instantiate aTagorNavigableStringobject to
contain that information. Instead of that default behavior, you can
tell Beautiful Soup to instantiatesubclassesofTagorNavigableString, subclasses you define with custom behavior:
This can be useful when incorporating Beautiful Soup into a test
framework.
(This is a new feature in Beautiful Soup 4.8.1.)
If you’re having trouble understanding what Beautiful Soup does to a
document, pass the document into thediagnose()function. (This function is new in
Beautiful Soup 4.2.0.) Beautiful Soup will print out a report showing
you how different parsers handle the document, and tell you if you’re
missing a parser that Beautiful Soup could be using:
Just looking at the output of diagnose() might show you how to solve the
problem. Even if not, you can paste the output ofdiagnose()when
asking for help.
There are two different kinds of parse errors. There are crashes,
where you feed a document to Beautiful Soup and it raises an
exception (usually anHTMLParser.HTMLParseError). And there is
unexpected behavior, where a Beautiful Soup parse tree looks a lot
different than the document used to create it.
These problems are almost never problems with Beautiful Soup itself.
This is not because Beautiful Soup is an amazingly well-written piece
of software. It’s because Beautiful Soup doesn’t include any parsing
code. Instead, it relies on external parsers. If one parser isn’t
working on a certain document, the best solution is to try a different
parser. SeeInstalling a parserfor details and a parser
comparison. If this doesn’t help, you might need to inspect the
document tree found inside theBeautifulSoupobject, to see where
the markup you’re looking for actually ended up.
SyntaxError:Invalidsyntax(on the lineROOT_TAG_NAME='[document]'): Caused by running an old Python 2 version of
Beautiful Soup under Python 3, without converting the code.
ImportError:NomodulenamedHTMLParser- Caused by running an old
Python 2 version of Beautiful Soup under Python 3.
ImportError:Nomodulenamedhtml.parser- Caused by running the
Python 3 version of Beautiful Soup under Python 2.
ImportError:NomodulenamedBeautifulSoup- Caused by running
Beautiful Soup 3 code in an environment that doesn’t have BS3
installed. Or, by writing Beautiful Soup 4 code without knowing that
the package name has changed tobs4.
ImportError:Nomodulenamedbs4- Caused by running Beautiful
Soup 4 code in an environment that doesn’t have BS4 installed.
By default, Beautiful Soup parses documents as HTML. To parse a
document as XML, pass in “xml” as the second argument to theBeautifulSoupconstructor:
You’ll need tohave lxml installed.
If your script works on one computer but not another, or in one
virtual environment but not another, or outside the virtual
environment but not inside, it’s probably because the two
environments have different parser libraries available. For example,
you may have developed the script on a computer that has lxml
installed, and then tried to run it on a computer that only has
html5lib installed. SeeDifferences between parsersfor why this
matters, and fix the problem by mentioning a specific parser library
in theBeautifulSoupconstructor.
BecauseHTML tags and attributes are case-insensitive, all three HTML
parsers convert tag and attribute names to lowercase. That is, the
markup <TAG></TAG> is converted to <tag></tag>. If you want to
preserve mixed-case or uppercase tags and attributes, you’ll need toparse the document as XML.
UnicodeEncodeError:'charmap'codeccan'tencodecharacter'\xfoo'inpositionbar(or just about any otherUnicodeEncodeError) - This problem shows up in two main
situations. First, when you try to print a Unicode character that
your console doesn’t know how to display. (Seethis page on the
Python wikifor help.)
Second, when you’re writing to a file and you pass in a Unicode
character that’s not supported by your default encoding. In this
case, the simplest solution is to explicitly encode the Unicode
string into UTF-8 withu.encode("utf8").
KeyError:[attr]- Caused by accessingtag['attr']when the
tag in question doesn’t define theattrattribute. The most
common errors areKeyError:'href'andKeyError:'class'.
Usetag.get('attr')if you’re not sureattris
defined, just as you would with a Python dictionary.
AttributeError:'ResultSet'objecthasnoattribute'foo'- This
usually happens because you expectedfind_all()to return a
single tag or string. Butfind_all()returns alistof tags
and strings–aResultSetobject. You need to iterate over the
list and look at the.fooof each one. Or, if you really only
want one result, you need to usefind()instead offind_all().
AttributeError:'NoneType'objecthasnoattribute'foo'- This
usually happens because you calledfind()and then tried to
access the.foo`attribute of the result. But in your case,find()didn’t find anything, so it returnedNone, instead of
returning a tag or a string. You need to figure out why yourfind()call isn’t returning anything.
AttributeError:'NavigableString'objecthasnoattribute'foo'- This usually happens because you’re treating a string as
though it were a tag. You may be iterating over a list, expecting
that it contains nothing but tags, when it actually contains both tags and
strings.
Beautiful Soup will never be as fast as the parsers it sits on top
of. If response time is critical, if you’re paying for computer time
by the hour, or if there’s any other reason why computer time is more
valuable than programmer time, you should forget about Beautiful Soup
and work directly atoplxml.
That said, there are things you can do to speed up Beautiful Soup. If
you’re not using lxml as the underlying parser, my advice is tostart. Beautiful Soup parses documents
significantly faster using lxml than using html.parser or html5lib.
You can speed up encoding detection significantly by installing thecchardetlibrary.
Parsing only part of a documentwon’t save you much time parsing
the document, but it can save a lot of memory, and it’ll makesearchingthe document much faster.
New translations of the Beautiful Soup documentation are greatly
appreciated. Translations should be licensed under the MIT license,
just like Beautiful Soup and its English documentation are.
There are two ways of getting your translation into the main code base
and onto the Beautiful Soup website:
Create a branch of the Beautiful Soup repository, add your
translation, and propose a merge with the main branch, the same
as you would do with a proposed change to the source code.
Send a message to the Beautiful Soup discussion group with a link to
your translation, or attach your translation to the message.
Use the Chinese or Brazilian Portuguese translations as your model. In
particular, please translate the source filedoc/source/index.rst,
rather than the HTML version of the documentation. This makes it
possible to publish the documentation in a variety of formats, not
just HTML.
Beautiful Soup 3 is the previous release series, and is no longer
supported. Development of Beautiful Soup 3 stopped in 2012, and the
package was completely discontinued in 2021. There’s no reason to
install it unless you’re trying to get very old software to work, but
it’s published through PyPi asBeautifulSoup:
$pipinstallBeautifulSoup
You can also downloada tarball of the final release, 3.2.2.
If you ranpipinstallbeautifulsouporpipinstallBeautifulSoup, but your code doesn’t work, you installed Beautiful
Soup 3 by mistake. You need to runpipinstallbeautifulsoup4.
The documentation for Beautiful Soup 3 is archived online.
Most code written against Beautiful Soup 3 will work against Beautiful
Soup 4 with one simple change. All you should have to do is change the
package name fromBeautifulSouptobs4. So this:
becomes this:
If you get theImportError“No module named BeautifulSoup”, your
problem is that you’re trying to run Beautiful Soup 3 code, but you
only have Beautiful Soup 4 installed.
If you get theImportError“No module named bs4”, your problem
is that you’re trying to run Beautiful Soup 4 code, but you only
have Beautiful Soup 3 installed.
Although BS4 is mostly backward-compatible with BS3, most of its
methods have been deprecated and given new names forPEP 8 compliance. There are numerous other
renames and changes, and a few of them break backward compatibility.
Here’s what you’ll need to know to convert your BS3 code and habits to BS4:
Beautiful Soup 3 used Python’sSGMLParser, a module that was
deprecated and removed in Python 3.0. Beautiful Soup 4 useshtml.parserby default, but you can plug in lxml or html5lib and
use that instead. SeeInstalling a parserfor a comparison.
Sincehtml.parseris not the same parser asSGMLParser, you
may find that Beautiful Soup 4 gives you a different parse tree than
Beautiful Soup 3 for the same markup. If you swap outhtml.parserfor lxml or html5lib, you may find that the parse tree changes yet
again. If this happens, you’ll need to update your scraping code to
process the new tree.
renderContents->encode_contents
replaceWith->replace_with
replaceWithChildren->unwrap
findAll->find_all
findAllNext->find_all_next
findAllPrevious->find_all_previous
findNext->find_next
findNextSibling->find_next_sibling
findNextSiblings->find_next_siblings
findParent->find_parent
findParents->find_parents
findPrevious->find_previous
findPreviousSibling->find_previous_sibling
findPreviousSiblings->find_previous_siblings
getText->get_text
nextSibling->next_sibling
previousSibling->previous_sibling
Some arguments to the Beautiful Soup constructor were renamed for the
same reasons:
BeautifulSoup(parseOnlyThese=...)->BeautifulSoup(parse_only=...)
BeautifulSoup(fromEncoding=...)->BeautifulSoup(from_encoding=...)
I renamed one method for compatibility with Python 3:
Tag.has_key()->Tag.has_attr()
I renamed one attribute to use more accurate terminology:
Tag.isSelfClosing->Tag.is_empty_element
I renamed three attributes to avoid using words that have special
meaning to Python. Unlike the others, these changes arenot backwards
compatible.If you used these attributes in BS3, your code will break
in BS4 until you change them.
UnicodeDammit.unicode->UnicodeDammit.unicode_markup
Tag.next->Tag.next_element
Tag.previous->Tag.previous_element
These methods are left over from the Beautiful Soup 2 API. They’ve
been deprecated since 2006 and should not be used at all:
Tag.fetchNextSiblings
Tag.fetchPreviousSiblings
Tag.fetchPrevious
Tag.fetchPreviousSiblings
Tag.fetchParents
Tag.findChild
Tag.findChildren
I gave the generators PEP 8-compliant names, and transformed them into
properties:
childGenerator()->children
nextGenerator()->next_elements
nextSiblingGenerator()->next_siblings
previousGenerator()->previous_elements
previousSiblingGenerator()->previous_siblings
recursiveChildGenerator()->descendants
parentGenerator()->parents
So instead of this:
You can write this:
(But the old code will still work.)
Some of the generators used to yieldNoneafter they were done, and
then stop. That was a bug. Now the generators just stop.
There are two new generators,.strings and
.stripped_strings..stringsyields
NavigableString objects, and.stripped_stringsyields Python
strings that have had whitespace stripped.
There is no longer aBeautifulStoneSoupclass for parsing XML. To
parse XML you pass in “xml” as the second argument to theBeautifulSoupconstructor. For the same reason, theBeautifulSoupconstructor no longer recognizes theisHTMLargument.
Beautiful Soup’s handling of empty-element XML tags has been
improved. Previously when you parsed XML you had to explicitly say
which tags were considered empty-element tags. TheselfClosingTagsargument to the constructor is no longer recognized. Instead,
Beautiful Soup considers any empty tag to be an empty-element tag. If
you add a child to an empty-element tag, it stops being an
empty-element tag.
An incoming HTML or XML entity is always converted into the
corresponding Unicode character. Beautiful Soup 3 had a number of
overlapping ways of dealing with entities, which have been
removed. TheBeautifulSoupconstructor no longer recognizes thesmartQuotesToorconvertEntitiesarguments. (Unicode,
Dammitstill hassmart_quotes_to, but its default is now to turn
smart quotes into Unicode.) The constantsHTML_ENTITIES,XML_ENTITIES, andXHTML_ENTITIEShave been removed, since they
configure a feature (transforming some but not all entities into
Unicode characters) that no longer exists.
If you want to turn Unicode characters back into HTML entities on
output, rather than turning them into UTF-8 characters, you need to
use anoutput formatter.
Tag.stringnow operates recursively. If tag A
contains a single tag B and nothing else, then A.string is the same as
B.string. (Previously, it was None.)
Multi-valued attributeslikeclasshave lists of strings as
their values, not simple strings. This may affect the way you search by CSS
class.
Tagobjects now implement the__hash__method, such that twoTagobjects are considered equal if they generate the same
markup. This may change your script’s behavior if you putTagobjects into a dictionary or set.
If you pass one of thefind*methods bothstringanda tag-specific argument likename, Beautiful Soup will
search for tags that match your tag-specific criteria and whoseTag.stringmatches yourstringvalue. It willnotfind the strings themselves. Previously,
Beautiful Soup ignored the tag-specific arguments and looked for
strings.
TheBeautifulSoupconstructor no longer recognizes themarkupMassageargument. It’s now the parser’s responsibility to
handle markup correctly.
The rarely-used alternate parser classes likeICantBelieveItsBeautifulSoupandBeautifulSOAPhave been
removed. It’s now the parser’s decision how to handle ambiguous
markup.
Theprettify()method now returns a Unicode string, not a bytestring.

==================================================

Content from: https://pytorch.org/docs/stable/index.html

Run PyTorch locally or get started quickly with one of the supported cloud platforms
Whats new in PyTorch tutorials
Familiarize yourself with PyTorch concepts and modules
Bite-size, ready-to-deploy PyTorch code examples
Master PyTorch basics with our engaging YouTube tutorial series
Learn about the tools and frameworks in the PyTorch Ecosystem
Join the PyTorch developer community to contribute, learn, and get your questions answered
A place to discuss PyTorch code, issues, install, research
Find resources and get questions answered
Award winners announced at this year's PyTorch Conference
Build innovative and privacy-aware AI experiences for edge devices
End-to-end solution for enabling on-device inference capabilities across mobile and edge devices
Explore the documentation for comprehensive guidance on how to use PyTorch
Read the PyTorch Domains documentation to learn more about domain-specific libraries
Catch up on the latest technical news and happenings
Stories from the PyTorch ecosystem
Learn about the latest PyTorch tutorials, new, and more
Learn how our community solves real, everyday machine learning problems with PyTorch
Find events, webinars, and podcasts
Learn more about the PyTorch Foundation

Community
Developer Notes
Language Bindings
Python API
Libraries
PyTorch is an optimized tensor library for deep learning using GPUs and CPUs.
Features described in this documentation are classified by release status:
Stable:These features will be maintained long-term and there should generally
be no major performance limitations or gaps in documentation.
We also expect to maintain backwards compatibility (although
breaking changes can happen and notice will be given one release ahead
of time).
Beta:These features are tagged as Beta because the API may change based on
user feedback, because the performance needs to improve, or because
coverage across operators is not yet complete. For Beta features, we are
committing to seeing the feature through to the Stable classification.
We are not, however, committing to backwards compatibility.
Prototype:These features are typically not available as part of
binary distributions like PyPI or Conda, except sometimes behind run-time
flags, and are at an early stage for feedback and testing.
Community
Developer Notes
Language Bindings
Python API
Libraries
Index
Module Index
© Copyright 2023, PyTorch Contributors.
Access comprehensive developer documentation for PyTorch
Get in-depth tutorials for beginners and advanced developers
Find development resources and get your questions answered
© Copyright The Linux Foundation. The PyTorch Foundation is a project of The Linux Foundation.
          For web site terms of use, trademark policy and other policies applicable to The PyTorch Foundation please seewww.linuxfoundation.org/policies/. The PyTorch Foundation supports the PyTorch open source
          project, which has been established as PyTorch Project a Series of LF Projects, LLC. For policies applicable to the PyTorch Project a Series of LF Projects, LLC,
          please seewww.lfprojects.org/policies/.
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebook’s Cookies Policy applies. Learn more, including about available controls:Cookies Policy.

==================================================

Content from: https://www.anaconda.com/

Python in Excel is available now to Microsoft Excel 365 users on Windows!
The world’s most trusted open ecosystem forsourcing, building, and deploying data science and AI initiatives
M
Makers & maintainers use Anaconda
M
Developers and contributors
M
Organizations use Anaconda
Financial Services
Revolutionize financial analytics and security with tailored AI solutions.
Public Sector
Evolve government operations and citizen engagement with secure data science and AI tools.
Healthcare
Transform patient care and healthcare operations with bespoke AI solutions.
Manufacturing
Drive efficiency and innovation in your manufacturing processes using advanced AI.
WHITE PAPER
Gain insights into community demographics, industry-specific use cases, and AI trends.
Newsand Insights
Docsand Learning
ForPractitioners
© 2024 Anaconda Inc. All rights reserved.

==================================================

